{"ast":null,"code":"import { Injectable, ɵɵdefineInjectable, forwardRef, EventEmitter, Component, ElementRef, ChangeDetectorRef, Input, Output, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Provides default values for Pagination and pager components\n */\nlet PaginationConfig = /*#__PURE__*/(() => {\n  class PaginationConfig {\n    constructor() {\n      this.main = {\n        maxSize: void 0,\n        itemsPerPage: 10,\n        boundaryLinks: false,\n        directionLinks: true,\n        firstText: 'First',\n        previousText: 'Previous',\n        nextText: 'Next',\n        lastText: 'Last',\n        pageBtnClass: '',\n        rotate: true\n      };\n      this.pager = {\n        itemsPerPage: 15,\n        previousText: '« Previous',\n        nextText: 'Next »',\n        pageBtnClass: '',\n        align: true\n      };\n    }\n  }\n  /** @nocollapse */PaginationConfig.ɵprov = ɵɵdefineInjectable({\n    factory: function PaginationConfig_Factory() {\n      return new PaginationConfig();\n    },\n    token: PaginationConfig,\n    providedIn: \"root\"\n  });\n  return PaginationConfig;\n})();\nif (false) {\n  /** @type {?} */\n  PaginationConfig.prototype.main;\n  /** @type {?} */\n  PaginationConfig.prototype.pager;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst PAGER_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  /* tslint:disable-next-line: no-use-before-declare */\n  useExisting: forwardRef(\n  /**\n  * @return {?}\n  */\n  () => PagerComponent),\n  multi: true\n};\nclass PagerComponent {\n  /**\n   * @param {?} elementRef\n   * @param {?} paginationConfig\n   * @param {?} changeDetection\n   */\n  constructor(elementRef, paginationConfig, changeDetection) {\n    this.elementRef = elementRef;\n    this.changeDetection = changeDetection;\n    /**\n     * fired when total pages count changes, $event:number equals to total pages count\n     */\n    this.numPages = new EventEmitter();\n    /**\n     * fired when page was changed, $event:{page, itemsPerPage} equals to\n     * object with current page index and number of items per page\n     */\n    this.pageChanged = new EventEmitter();\n    this.onChange = Function.prototype;\n    this.onTouched = Function.prototype;\n    this.inited = false;\n    this._page = 1;\n    this.elementRef = elementRef;\n    if (!this.config) {\n      this.configureOptions(Object.assign({}, paginationConfig.main, paginationConfig.pager));\n    }\n  }\n  /**\n   * maximum number of items per page. If value less than 1 will display all items on one page\n   * @return {?}\n   */\n  get itemsPerPage() {\n    return this._itemsPerPage;\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n  set itemsPerPage(v) {\n    this._itemsPerPage = v;\n    this.totalPages = this.calculateTotalPages();\n  }\n  /**\n   * total number of items in all pages\n   * @return {?}\n   */\n  get totalItems() {\n    return this._totalItems;\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n  set totalItems(v) {\n    this._totalItems = v;\n    this.totalPages = this.calculateTotalPages();\n  }\n  /**\n   * @return {?}\n   */\n  get totalPages() {\n    return this._totalPages;\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n  set totalPages(v) {\n    this._totalPages = v;\n    this.numPages.emit(v);\n    if (this.inited) {\n      this.selectPage(this.page);\n    }\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set page(value) {\n    /** @type {?} */\n    const _previous = this._page;\n    this._page = value > this.totalPages ? this.totalPages : value || 1;\n    this.changeDetection.markForCheck();\n    if (_previous === this._page || typeof _previous === 'undefined') {\n      return;\n    }\n    this.pageChanged.emit({\n      page: this._page,\n      itemsPerPage: this.itemsPerPage\n    });\n  }\n  /**\n   * @return {?}\n   */\n  get page() {\n    return this._page;\n  }\n  /**\n   * @param {?} config\n   * @return {?}\n   */\n  configureOptions(config) {\n    this.config = Object.assign({}, config);\n  }\n  /**\n   * @return {?}\n   */\n  ngOnInit() {\n    if (typeof window !== 'undefined') {\n      this.classMap = this.elementRef.nativeElement.getAttribute('class') || '';\n    }\n    // watch for maxSize\n    this.maxSize = typeof this.maxSize !== 'undefined' ? this.maxSize : this.config.maxSize;\n    this.rotate = typeof this.rotate !== 'undefined' ? this.rotate : this.config.rotate;\n    this.boundaryLinks = typeof this.boundaryLinks !== 'undefined' ? this.boundaryLinks : this.config.boundaryLinks;\n    this.directionLinks = typeof this.directionLinks !== 'undefined' ? this.directionLinks : this.config.directionLinks;\n    this.pageBtnClass = typeof this.pageBtnClass !== 'undefined' ? this.pageBtnClass : this.config.pageBtnClass;\n    // base class\n    this.itemsPerPage = typeof this.itemsPerPage !== 'undefined' ? this.itemsPerPage : this.config.itemsPerPage;\n    this.totalPages = this.calculateTotalPages();\n    // this class\n    this.pages = this.getPages(this.page, this.totalPages);\n    this.inited = true;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  writeValue(value) {\n    this.page = value;\n    this.pages = this.getPages(this.page, this.totalPages);\n  }\n  /**\n   * @param {?} key\n   * @return {?}\n   */\n  getText(key) {\n    // tslint:disable-next-line:no-any\n    return (/** @type {?} */this[`${key}Text`] || /** @type {?} */this.config[`${key}Text`]\n    );\n  }\n  /**\n   * @return {?}\n   */\n  noPrevious() {\n    return this.page === 1;\n  }\n  /**\n   * @return {?}\n   */\n  noNext() {\n    return this.page === this.totalPages;\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnChange(fn) {\n    this.onChange = fn;\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n  /**\n   * @param {?} page\n   * @param {?=} event\n   * @return {?}\n   */\n  selectPage(page, event) {\n    if (event) {\n      event.preventDefault();\n    }\n    if (!this.disabled) {\n      if (event && event.target) {\n        // tslint:disable-next-line:no-any\n        /** @type {?} */\n        const target = event.target;\n        target.blur();\n      }\n      this.writeValue(page);\n      this.onChange(this.page);\n    }\n  }\n  // Create page object used in template\n  /**\n   * @protected\n   * @param {?} num\n   * @param {?} text\n   * @param {?} active\n   * @return {?}\n   */\n  makePage(num, text, active) {\n    return {\n      text,\n      number: num,\n      active\n    };\n  }\n  /**\n   * @protected\n   * @param {?} currentPage\n   * @param {?} totalPages\n   * @return {?}\n   */\n  getPages(currentPage, totalPages) {\n    /** @type {?} */\n    const pages = [];\n    // Default page limits\n    /** @type {?} */\n    let startPage = 1;\n    /** @type {?} */\n    let endPage = totalPages;\n    /** @type {?} */\n    const isMaxSized = typeof this.maxSize !== 'undefined' && this.maxSize < totalPages;\n    // recompute if maxSize\n    if (isMaxSized) {\n      if (this.rotate) {\n        // Current page is displayed in the middle of the visible ones\n        startPage = Math.max(currentPage - Math.floor(this.maxSize / 2), 1);\n        endPage = startPage + this.maxSize - 1;\n        // Adjust if limit is exceeded\n        if (endPage > totalPages) {\n          endPage = totalPages;\n          startPage = endPage - this.maxSize + 1;\n        }\n      } else {\n        // Visible pages are paginated with maxSize\n        startPage = (Math.ceil(currentPage / this.maxSize) - 1) * this.maxSize + 1;\n        // Adjust last page if limit is exceeded\n        endPage = Math.min(startPage + this.maxSize - 1, totalPages);\n      }\n    }\n    // Add page number links\n    for (let num = startPage; num <= endPage; num++) {\n      /** @type {?} */\n      const page = this.makePage(num, num.toString(), num === currentPage);\n      pages.push(page);\n    }\n    // Add links to move between page sets\n    if (isMaxSized && !this.rotate) {\n      if (startPage > 1) {\n        /** @type {?} */\n        const previousPageSet = this.makePage(startPage - 1, '...', false);\n        pages.unshift(previousPageSet);\n      }\n      if (endPage < totalPages) {\n        /** @type {?} */\n        const nextPageSet = this.makePage(endPage + 1, '...', false);\n        pages.push(nextPageSet);\n      }\n    }\n    return pages;\n  }\n  // base class\n  /**\n   * @protected\n   * @return {?}\n   */\n  calculateTotalPages() {\n    /** @type {?} */\n    const totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil(this.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  }\n}\n\n/** @nocollapse */\n\nif (false) {\n  /** @type {?} */\n  PagerComponent.prototype.config;\n  /**\n   * if `true` aligns each link to the sides of pager\n   * @type {?}\n   */\n  PagerComponent.prototype.align;\n  /**\n   * limit number for page links in pager\n   * @type {?}\n   */\n  PagerComponent.prototype.maxSize;\n  /**\n   * if false first and last buttons will be hidden\n   * @type {?}\n   */\n  PagerComponent.prototype.boundaryLinks;\n  /**\n   * if false previous and next buttons will be hidden\n   * @type {?}\n   */\n  PagerComponent.prototype.directionLinks;\n  /**\n   * first button text\n   * @type {?}\n   */\n  PagerComponent.prototype.firstText;\n  /**\n   * previous button text\n   * @type {?}\n   */\n  PagerComponent.prototype.previousText;\n  /**\n   * next button text\n   * @type {?}\n   */\n  PagerComponent.prototype.nextText;\n  /**\n   * last button text\n   * @type {?}\n   */\n  PagerComponent.prototype.lastText;\n  /**\n   * if true current page will in the middle of pages list\n   * @type {?}\n   */\n  PagerComponent.prototype.rotate;\n  /**\n   * add class to <code><li\\></code>\n   * @type {?}\n   */\n  PagerComponent.prototype.pageBtnClass;\n  /**\n   * if true pagination component will be disabled\n   * @type {?}\n   */\n  PagerComponent.prototype.disabled;\n  /**\n   * fired when total pages count changes, $event:number equals to total pages count\n   * @type {?}\n   */\n  PagerComponent.prototype.numPages;\n  /**\n   * fired when page was changed, $event:{page, itemsPerPage} equals to\n   * object with current page index and number of items per page\n   * @type {?}\n   */\n  PagerComponent.prototype.pageChanged;\n  /** @type {?} */\n  PagerComponent.prototype.onChange;\n  /** @type {?} */\n  PagerComponent.prototype.onTouched;\n  /** @type {?} */\n  PagerComponent.prototype.classMap;\n  /** @type {?} */\n  PagerComponent.prototype.pages;\n  /**\n   * @type {?}\n   * @protected\n   */\n  PagerComponent.prototype._itemsPerPage;\n  /**\n   * @type {?}\n   * @protected\n   */\n  PagerComponent.prototype._totalItems;\n  /**\n   * @type {?}\n   * @protected\n   */\n  PagerComponent.prototype._totalPages;\n  /**\n   * @type {?}\n   * @protected\n   */\n  PagerComponent.prototype.inited;\n  /**\n   * @type {?}\n   * @protected\n   */\n  PagerComponent.prototype._page;\n  /**\n   * @type {?}\n   * @private\n   */\n  PagerComponent.prototype.elementRef;\n  /**\n   * @type {?}\n   * @private\n   */\n  PagerComponent.prototype.changeDetection;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction PageChangedEvent() {}\nif (false) {\n  /** @type {?} */\n  PageChangedEvent.prototype.itemsPerPage;\n  /** @type {?} */\n  PageChangedEvent.prototype.page;\n}\n/** @type {?} */\nconst PAGINATION_CONTROL_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  /* tslint:disable-next-line: no-use-before-declare */\n  useExisting: forwardRef(\n  /**\n  * @return {?}\n  */\n  () => PaginationComponent),\n  multi: true\n};\nclass PaginationComponent {\n  /**\n   * @param {?} elementRef\n   * @param {?} paginationConfig\n   * @param {?} changeDetection\n   */\n  constructor(elementRef, paginationConfig, changeDetection) {\n    this.elementRef = elementRef;\n    this.changeDetection = changeDetection;\n    /**\n     * fired when total pages count changes, $event:number equals to total pages count\n     */\n    this.numPages = new EventEmitter();\n    /**\n     * fired when page was changed, $event:{page, itemsPerPage} equals to object\n     * with current page index and number of items per page\n     */\n    this.pageChanged = new EventEmitter();\n    this.onChange = Function.prototype;\n    this.onTouched = Function.prototype;\n    this.inited = false;\n    this._page = 1;\n    this.elementRef = elementRef;\n    if (!this.config) {\n      this.configureOptions(paginationConfig.main);\n    }\n  }\n  /**\n   * maximum number of items per page. If value less than 1 will display all items on one page\n   * @return {?}\n   */\n  get itemsPerPage() {\n    return this._itemsPerPage;\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n  set itemsPerPage(v) {\n    this._itemsPerPage = v;\n    this.totalPages = this.calculateTotalPages();\n  }\n  /**\n   * total number of items in all pages\n   * @return {?}\n   */\n  get totalItems() {\n    return this._totalItems;\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n  set totalItems(v) {\n    this._totalItems = v;\n    this.totalPages = this.calculateTotalPages();\n  }\n  /**\n   * @return {?}\n   */\n  get totalPages() {\n    return this._totalPages;\n  }\n  /**\n   * @param {?} v\n   * @return {?}\n   */\n  set totalPages(v) {\n    this._totalPages = v;\n    this.numPages.emit(v);\n    if (this.inited) {\n      this.selectPage(this.page);\n    }\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  set page(value) {\n    /** @type {?} */\n    const _previous = this._page;\n    this._page = value > this.totalPages ? this.totalPages : value || 1;\n    this.changeDetection.markForCheck();\n    if (_previous === this._page || typeof _previous === 'undefined') {\n      return;\n    }\n    this.pageChanged.emit({\n      page: this._page,\n      itemsPerPage: this.itemsPerPage\n    });\n  }\n  /**\n   * @return {?}\n   */\n  get page() {\n    return this._page;\n  }\n  /**\n   * @param {?} config\n   * @return {?}\n   */\n  configureOptions(config) {\n    this.config = Object.assign({}, config);\n  }\n  /**\n   * @return {?}\n   */\n  ngOnInit() {\n    if (typeof window !== 'undefined') {\n      this.classMap = this.elementRef.nativeElement.getAttribute('class') || '';\n    }\n    // watch for maxSize\n    this.maxSize = typeof this.maxSize !== 'undefined' ? this.maxSize : this.config.maxSize;\n    this.rotate = typeof this.rotate !== 'undefined' ? this.rotate : this.config.rotate;\n    this.boundaryLinks = typeof this.boundaryLinks !== 'undefined' ? this.boundaryLinks : this.config.boundaryLinks;\n    this.directionLinks = typeof this.directionLinks !== 'undefined' ? this.directionLinks : this.config.directionLinks;\n    this.pageBtnClass = typeof this.pageBtnClass !== 'undefined' ? this.pageBtnClass : this.config.pageBtnClass;\n    // base class\n    this.itemsPerPage = typeof this.itemsPerPage !== 'undefined' ? this.itemsPerPage : this.config.itemsPerPage;\n    this.totalPages = this.calculateTotalPages();\n    // this class\n    this.pages = this.getPages(this.page, this.totalPages);\n    this.inited = true;\n  }\n  /**\n   * @param {?} value\n   * @return {?}\n   */\n  writeValue(value) {\n    this.page = value;\n    this.pages = this.getPages(this.page, this.totalPages);\n  }\n  /**\n   * @param {?} key\n   * @return {?}\n   */\n  getText(key) {\n    // tslint:disable-next-line:no-any\n    return (/** @type {?} */this[`${key}Text`] || /** @type {?} */this.config[`${key}Text`]\n    );\n  }\n  /**\n   * @return {?}\n   */\n  noPrevious() {\n    return this.page === 1;\n  }\n  /**\n   * @return {?}\n   */\n  noNext() {\n    return this.page === this.totalPages;\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnChange(fn) {\n    this.onChange = fn;\n  }\n  /**\n   * @param {?} fn\n   * @return {?}\n   */\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n  /**\n   * @param {?} page\n   * @param {?=} event\n   * @return {?}\n   */\n  selectPage(page, event) {\n    if (event) {\n      event.preventDefault();\n    }\n    if (!this.disabled) {\n      if (event && event.target) {\n        // tslint:disable-next-line:no-any\n        /** @type {?} */\n        const target = event.target;\n        target.blur();\n      }\n      this.writeValue(page);\n      this.onChange(this.page);\n    }\n  }\n  // Create page object used in template\n  /**\n   * @protected\n   * @param {?} num\n   * @param {?} text\n   * @param {?} active\n   * @return {?}\n   */\n  makePage(num, text, active) {\n    return {\n      text,\n      number: num,\n      active\n    };\n  }\n  /**\n   * @protected\n   * @param {?} currentPage\n   * @param {?} totalPages\n   * @return {?}\n   */\n  getPages(currentPage, totalPages) {\n    /** @type {?} */\n    const pages = [];\n    // Default page limits\n    /** @type {?} */\n    let startPage = 1;\n    /** @type {?} */\n    let endPage = totalPages;\n    /** @type {?} */\n    const isMaxSized = typeof this.maxSize !== 'undefined' && this.maxSize < totalPages;\n    // recompute if maxSize\n    if (isMaxSized) {\n      if (this.rotate) {\n        // Current page is displayed in the middle of the visible ones\n        startPage = Math.max(currentPage - Math.floor(this.maxSize / 2), 1);\n        endPage = startPage + this.maxSize - 1;\n        // Adjust if limit is exceeded\n        if (endPage > totalPages) {\n          endPage = totalPages;\n          startPage = endPage - this.maxSize + 1;\n        }\n      } else {\n        // Visible pages are paginated with maxSize\n        startPage = (Math.ceil(currentPage / this.maxSize) - 1) * this.maxSize + 1;\n        // Adjust last page if limit is exceeded\n        endPage = Math.min(startPage + this.maxSize - 1, totalPages);\n      }\n    }\n    // Add page number links\n    for (let num = startPage; num <= endPage; num++) {\n      /** @type {?} */\n      const page = this.makePage(num, num.toString(), num === currentPage);\n      pages.push(page);\n    }\n    // Add links to move between page sets\n    if (isMaxSized && !this.rotate) {\n      if (startPage > 1) {\n        /** @type {?} */\n        const previousPageSet = this.makePage(startPage - 1, '...', false);\n        pages.unshift(previousPageSet);\n      }\n      if (endPage < totalPages) {\n        /** @type {?} */\n        const nextPageSet = this.makePage(endPage + 1, '...', false);\n        pages.push(nextPageSet);\n      }\n    }\n    return pages;\n  }\n  // base class\n  /**\n   * @protected\n   * @return {?}\n   */\n  calculateTotalPages() {\n    /** @type {?} */\n    const totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil(this.totalItems / this.itemsPerPage);\n    return Math.max(totalPages || 0, 1);\n  }\n}\n\n/** @nocollapse */\n\nif (false) {\n  /** @type {?} */\n  PaginationComponent.prototype.config;\n  /**\n   * if `true` aligns each link to the sides of pager\n   * @type {?}\n   */\n  PaginationComponent.prototype.align;\n  /**\n   * limit number for page links in pager\n   * @type {?}\n   */\n  PaginationComponent.prototype.maxSize;\n  /**\n   * if false first and last buttons will be hidden\n   * @type {?}\n   */\n  PaginationComponent.prototype.boundaryLinks;\n  /**\n   * if false previous and next buttons will be hidden\n   * @type {?}\n   */\n  PaginationComponent.prototype.directionLinks;\n  /**\n   * first button text\n   * @type {?}\n   */\n  PaginationComponent.prototype.firstText;\n  /**\n   * previous button text\n   * @type {?}\n   */\n  PaginationComponent.prototype.previousText;\n  /**\n   * next button text\n   * @type {?}\n   */\n  PaginationComponent.prototype.nextText;\n  /**\n   * last button text\n   * @type {?}\n   */\n  PaginationComponent.prototype.lastText;\n  /**\n   * if true current page will in the middle of pages list\n   * @type {?}\n   */\n  PaginationComponent.prototype.rotate;\n  /**\n   * add class to <code><li\\></code>\n   * @type {?}\n   */\n  PaginationComponent.prototype.pageBtnClass;\n  /**\n   * if true pagination component will be disabled\n   * @type {?}\n   */\n  PaginationComponent.prototype.disabled;\n  /**\n   * custom template for page link\n   * @type {?}\n   */\n  PaginationComponent.prototype.customPageTemplate;\n  /**\n   * custom template for next link\n   * @type {?}\n   */\n  PaginationComponent.prototype.customNextTemplate;\n  /**\n   * custom template for previous link\n   * @type {?}\n   */\n  PaginationComponent.prototype.customPreviousTemplate;\n  /**\n   * custom template for first link\n   * @type {?}\n   */\n  PaginationComponent.prototype.customFirstTemplate;\n  /**\n   * custom template for last link\n   * @type {?}\n   */\n  PaginationComponent.prototype.customLastTemplate;\n  /**\n   * fired when total pages count changes, $event:number equals to total pages count\n   * @type {?}\n   */\n  PaginationComponent.prototype.numPages;\n  /**\n   * fired when page was changed, $event:{page, itemsPerPage} equals to object\n   * with current page index and number of items per page\n   * @type {?}\n   */\n  PaginationComponent.prototype.pageChanged;\n  /** @type {?} */\n  PaginationComponent.prototype.onChange;\n  /** @type {?} */\n  PaginationComponent.prototype.onTouched;\n  /** @type {?} */\n  PaginationComponent.prototype.classMap;\n  /** @type {?} */\n  PaginationComponent.prototype.pages;\n  /**\n   * @type {?}\n   * @protected\n   */\n  PaginationComponent.prototype._itemsPerPage;\n  /**\n   * @type {?}\n   * @protected\n   */\n  PaginationComponent.prototype._totalItems;\n  /**\n   * @type {?}\n   * @protected\n   */\n  PaginationComponent.prototype._totalPages;\n  /**\n   * @type {?}\n   * @protected\n   */\n  PaginationComponent.prototype.inited;\n  /**\n   * @type {?}\n   * @protected\n   */\n  PaginationComponent.prototype._page;\n  /**\n   * @type {?}\n   * @private\n   */\n  PaginationComponent.prototype.elementRef;\n  /**\n   * @type {?}\n   * @private\n   */\n  PaginationComponent.prototype.changeDetection;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass PaginationModule {\n  /**\n   * @return {?}\n   */\n  static forRoot() {\n    return {\n      ngModule: PaginationModule,\n      providers: []\n    };\n  }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { PagerComponent, PaginationComponent, PaginationConfig, PaginationModule, PAGER_CONTROL_VALUE_ACCESSOR as ɵa, PAGINATION_CONTROL_VALUE_ACCESSOR as ɵb };\n//# sourceMappingURL=ngx-bootstrap-pagination.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}